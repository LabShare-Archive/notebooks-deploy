apiVersion: v1
kind: ConfigMap
metadata:
  name: jupyterhub-config
data:
  jupyterhub-config.py: |
    import os,sys
    import string
    import pickle
    import escapism
    from oauthenticator.generic import GenericOAuthenticator

    c = get_config()
    c.JupyterHub.spawner_class = 'modularspawner.ModularSpawner'
    c.ModularSpawner.start_timeout=1000

    # Choose which stacks to use in modular spawner
    stacks_path = '/stacks/deploy/docker/notebook/stacks'
    c.ModularSpawner.stacks_path = stacks_path
    c.ModularSpawner.base = 'BASE_STACK_VALUE'
    c.ModularSpawner.stacks = STACKS_VALUE
    c.ModularSpawner.stacks_names = STACKS_NAMES_VALUE

    c.ModularSpawner.default_url = '/lab'
    c.ModularSpawner.uid = 1000 #uid 1000 corresponds to jovyan, uid 0 to root
    c.ModularSpawner.cmd = ['jupyter-labhub']
    c.ModularSpawner.args = ['--collaborative']
    c.ModularSpawner.working_dir = '/home/jovyan'
    c.ModularSpawner.service_account='jupyteruser-sa'
    c.ModularSpawner.singleuser_image_pull_policy= 'Always'

    # Per-user storage configuration
    c.ModularSpawner.pvc_name_template = 'claim-{username}'
    c.ModularSpawner.storage_class = 'STORAGE_CLASS_VALUE'
    c.ModularSpawner.storage_capacity = 'STORAGE_PER_USER_VALUE'
    c.ModularSpawner.storage_access_modes = ['ReadWriteOnce']
    c.ModularSpawner.storage_pvc_ensure = True

    # Volumes to attach to Pod
    c.ModularSpawner.volumes = [
        {
            'name': 'volume-{username}',
            'persistentVolumeClaim': {
                'claimName': 'claim-{username}'
            }
        },
        {
            'name': 'shared-volume',
            'persistentVolumeClaim': {
                'claimName': 'notebooks-pv-claim'
            }
        },
        {
            'name': 'wipp-volume',
            'persistentVolumeClaim': {
                'claimName': 'WIPP_STORAGE_PVC_VALUE'
            }
        }
    ]

    # Where to mount volumes
    c.ModularSpawner.volume_mounts = [
        {
            'mountPath': '/home/jovyan/work',
            'name': 'volume-{username}'
        },
        {
            'mountPath': '/opt/shared/notebooks',
            'name': 'shared-volume'
        },
        {
            'mountPath': '/opt/shared/wipp',
            'name': 'wipp-volume'
        }
    ]

    # Calculate minimal image using railyard
    import subprocess
    tag = subprocess.run(('railyard hash -b ' + os.path.join(stacks_path, 'BASE_STACK_VALUE')).split(' '), capture_output=True).stdout.decode("utf-8").rstrip()


    c.ModularSpawner.profile_list = [
        {
            'display_name': 'Minimal Notebook',
            'slug': 'minimal-notebook',
            'kubespawner_override': {
                'image': 'labshare/polyglot-notebook:' + tag
            }
        }, {
            'display_name': 'Streamlit Dashboard Variable App',
            'slug': 'jhsingle-streamlit-variable',  
            'kubespawner_override': {
                'image': 'polusai/hub-streamlit'
            }
        }, {
            'display_name': 'Voila Dashboard Variable App',
            'slug': 'jhsingle-voila-variable',  
            'kubespawner_override': {
                'image': 'polusai/hub-voila'
            }
        }, {
        'display_name': 'JupyterLab WIPP Plugin Creator testing',
            'slug': 'jupyterlab-plugin-creator',  
            'kubespawner_override': {
                'image': 'ktaletsk/jupyterlab-plugin-creator:0.1.10'
            }
        }
    ]

    c.JupyterHub.allow_named_servers=True
    c.JupyterHub.ip='0.0.0.0'
    c.JupyterHub.hub_ip='0.0.0.0'

    # Required for AWS
    c.JupyterHub.hub_connect_ip='jupyterhub-internal'

    # Configure Postgres database
    postgres_db = os.getenv('POSTGRES_DB')
    postgres_user = os.getenv('POSTGRES_USER')
    postgres_password = os.getenv('POSTGRES_PASSWORD')
    c.JupyterHub.db_url = 'postgresql://' + postgres_user + ':' + postgres_password + '@' + 'jupyterhub-postgres-service' + '/' + postgres_db

    c.JupyterHub.cleanup_servers=False
    c.JupyterHub.cookie_secret_file = '/srv/jupyterhub/jupyterhub_cookie_secret'

    OAUTH_CLIENT_ID = os.getenv('OAUTH_CLIENT_ID')
    OAUTH_CLIENT_SECRET = os.getenv('OAUTH_CLIENT_SECRET')
    ADMIN_USERS = os.getenv('ADMIN_USERS')
    ADMIN_SERVICE_ACC = os.getenv('ADMIN_SERVICE_ACC')

    c.JupyterHub.authenticator_class = GenericOAuthenticator

    c.Authenticator.admin_users = set(ADMIN_USERS.split(';'))

    c.GenericOAuthenticator.client_id = OAUTH_CLIENT_ID
    c.GenericOAuthenticator.client_secret = OAUTH_CLIENT_SECRET
    c.GenericOAuthenticator.username_key = "email"
    c.GenericOAuthenticator.userdata_method = "GET"
    c.GenericOAuthenticator.extra_params = dict(client_id=OAUTH_CLIENT_ID, client_secret=OAUTH_CLIENT_SECRET)
    c.GenericOAuthenticator.basic_auth = False
    c.GenericOAuthenticator.auto_login = True

    # Read the users and groups backed up by config-wrapper
    try:
        infile = open('users.pkl','rb')
        users = pickle.load(infile)
        infile.close()
    except:
        users = []
    
    try:
        infile = open('groups.pkl','rb')
        groups_backup = pickle.load(infile)
        infile.close()
    except:
        groups_backup = {}

    # Create RBAC groups and roles
    groups = {}
    roles = []

    safe_chars = set(string.ascii_lowercase + string.digits)
    for user in users:
        # Escape symbols not allowed in role and group names
        safe_username = escapism.escape(user, safe=safe_chars).lower()

        group = {f'server_sharing_{safe_username}': groups_backup.get(f'server_sharing_{safe_username}', [])}
        groups.update(group)

        sharing_role = {
            'name': f'server_sharing_{safe_username}_role',
            'description': f'Server sharing of {user}',
            'scopes': [f'access:servers!user={user}'],
            'groups': [f'server_sharing_{safe_username}']
        }

        sharing_group_editing_role = {
            'name': f'server_sharing_{safe_username}_group_editing_role',
            'description': f'Edit server_sharing_{safe_username} group',
            'scopes': [f'groups!group=server_sharing_{safe_username}'],
            'users': [user]
        }

        usernames_reading_role = {
            'name': f'usernames_reading_{safe_username}_role',
            'description': 'Usernames reading group',
            'scopes': ['list:users'],
            'users': [user]
        }

        roles.append(sharing_role)
        roles.append(sharing_group_editing_role)
        roles.append(usernames_reading_role)

    # Required for getting user reading scope in the JUPYTERHUB_API_TOKEN on user server
    roles.append({
        'name': 'server',
        'scopes': ['all'],
    })

    c.JupyterHub.load_groups = groups
    c.JupyterHub.load_roles = roles

    # Set up WIPP UI urls for integration with WIPP
    c.ModularSpawner.environment = {
        'WIPP_UI_URL': 'WIPP_UI_VALUE',
        'WIPP_API_INTERNAL_URL': 'WIPP_API_INTERNAL_VALUE',
        'WIPP_NOTEBOOKS_PATH': 'WIPP_NOTEBOOKS_PATH_VALUE',
        'PLUGIN_TEMP_PATH': 'WIPP_PLUGIN_TEMP_PATH_VALUE',
        'USER_OPTIONS': lambda spawner: str(spawner.user_options)
    }

    c.JupyterHub.services = [
        {
            # Service to shutdown inactive Notebook servers after --timeout seconds
            'name': 'cull-idle', 
            'admin': True,
            'command': [sys.executable, '/srv/jupyterhub/config/cull-idle-servers.py', '--timeout=3600'],
        },
        {
            # Service admin token (used in Notebooks Hub and config-wrapper)
            "name": "service-token",
            "admin": True,
            "api_token": ADMIN_SERVICE_ACC,
        },
    ]
---